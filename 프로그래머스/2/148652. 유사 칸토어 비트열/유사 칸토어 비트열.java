// 0번째 유사 칸토어 비트열은 1
// 1번째 유사 칸토어 비트열은 1을 11011로 치환하여 11011 (1)
// 2번째 유사 칸토어 비트얼은
// 1 => 11011
// 1 => 11011
// 0 => 00000
// 1 => 11011
// 1 => 11011
// 다음과 같이 치환하여 => 1101111011000001101111011 
// 11011110110000011011110111101111011000001101111011000000000000000000000000011011110110000011011110111101111011000001101111011

// 110
// 11110110000011
// 011110
// 11110111
// 1011000001101111011
// 000000000000000000000000011011110110000011011110111101111011000001101111011

// 4번째는
// 1101111011000001101111011 (4 => 100)
// 1101111011000001101111011
// 0000000000000000000000000
// 1101111011000001101111011
// 1101111011000001101111011
// 1101111011000001101111011
// 1101111011000001101111011
// 0000000000000000000000000
// 1101111011000001101111011
// 1101111011000001101111011
// 0000000000000000000000000
// 0000000000000000000000000
// 0000000000000000000000000
// 0000000000000000000000000
// 0000000000000000000000000
// 1101111011000001101111011
// 1101111011000001101111011
// 0000000000000000000000000
// 1101111011000001101111011
// 1101111011000001101111011
// 1101111011000001101111011
// 1101111011000001101111011
// 0000000000000000000000000
// 1101111011000001101111011
// 1101111011000001101111011
public class Solution {


    public int solution(int n, long l, long r) {
        return (int)(countOnes(n, 1, powerByFive(n), l, r));
    }

    // n번째 비트열의 [start, end] 구간 내에서, [l, r]와 겹치는 구간 1 개수 계산
    private long countOnes(int n, long start, long end, long l, long r) {
        
        
        // 겹치는 구간 없으면 0
        if (r < start || l > end) {
            return 0;
        };
        
        // n=0 이면 "1" 하나만 있음
        if (n == 0) return 1;        
            
        // 전체 구간 길이
        long length = (end - start + 1);
        // 한 구간 길이
        long partLen = length / 5;

        // 치환 문자열 "11011"에서 각 부분 1 여부
        int[] pattern = {1,1,0,1,1};

        long total = 0;
        for (int i = 0; i < 5; i++) {
            long partStart = start + i * partLen;
            long partEnd = partStart + partLen - 1;

            if (pattern[i] == 0) {
                // 0으로 치환된 구간은 모두 0이므로 건너뜀
                continue;
            }
            // 재귀로 해당 구간 1의 개수 계산
            total += countOnes(n - 1, partStart, partEnd, l, r);
        }
        return total;
    }
    
    // 5^n 계산 (long)
    private long powerByFive(int n) {
        return (long) Math.pow(5, n);        
    }    
}
